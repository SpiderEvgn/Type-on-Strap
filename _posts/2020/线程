什么是 用户态 内核态？
现代操作系统分用户态和内核态，即操作系统的权重要比普通应用程序高，比如所有应用程序（用户态）与底层硬件的交互都通过调用操作系统（内核态）的库函数实现。
也就不会出现从前一个应用程序就把操作系统搞宕机的情况，因为应用程序不再有权限动到操作系统的内存。

java 的线程 和 GO 的协程（routine）
java 重量级线程，hotspot（JVM实现）把线程调度直接交给了 OS，每有一个 JVM 线程创建，它就直接调用 OS 创建一个 OS 层的线程，即 JVM 的所有线程管理都是直接交由操作系统完成。


什么是计算机的 重量级 和 轻量级
重量级表示操作系统调度（OS 代为管理），轻量级表示用户端（虚拟机）自己搞定

进程（静态） 是分配资源的基本单位，线程（动态） 是执行操作的基本单位


多线程（并发）的典型问题就是资源竞争，都在写同一个变量，解决方法就是锁。

CAS（compare and swap/exchange）
乐观锁或自旋锁，轻量级，不需要 OS 调度。简单来说，控制逻辑就是，执行完往回写值的时候对比源数据是否有改变，没改变就成功写值，改变了则代表期间有别的线程已经操作，则继续在现值上重新执行。

ABA 问题
即乐观锁写值的时候，原值的确没变，但却是被改了两次，别入从 A 改成 B 又改回了 A。解决方法就是加版本号

CAS 的问题，不具备原子性，即 compare 发现数据没改变可以写值，但是在 swap 写值之前恰好被别的线程改了值，于是结果错误。

CAS 最终的执行落实到汇编，由加上 lock 的汇编原语 cmpxchg 执行，cmpxchg 本身也并非原子性，但是 lock 保证了原子操作，即硬件锁。是否执行 lock 的判断是多核，如果单 CPU 单核当然就不用锁了，因为硬件限制了只有单线程。

锁升级
偏向锁 -> 轻量级锁（自旋锁）-> 重量级锁
自旋锁在等待的时候消耗 CPU 资源，无序等待，抢占资源。
重量级锁由 OS 调度，线程进入等待队列，不消耗 CPU 资源。